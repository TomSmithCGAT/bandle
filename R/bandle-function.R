##' These function implement the bandle model for dynamic mass spectrometry based
##' spatial proteomics datasets using MCMC for inference
##' 
##' The `bandle` function generate the sample from the posterior distributions
##' (object or class `bandleParams`) based on an annotated quantitative spatial
##' proteomics datasets (object of class [`MSnbase::MSnSet`]). Both are then
##' passed to the `bandlePredict` function to predict the sub-cellular localisation
##' and compute the differential localisation probability of proteins. See the
##' vignette for examples
##' 
##' @title Differential localisation experiments using the bandle method
##' @param objectCond1 A list of [`MSnbase::MSnSet`]s where each is an experimental
##' replicate for the first condition, usually a control
##' @param objectCond2 A list of [`MSnbase::MSnSet`]s where each is an experimental
##' replicate for the second condition, usually a treatment
##' @param fcol The feature meta-data containing marker definitions. Default is
##' `markers`
##' @param hyperLearn. Algorithm to learn posterior hyperparameters of the Gaussian
##' processes. Default is `LBFGS` and `MH` for metropolis-hastings is also implemented. 
##' @param numIter The number of iterations of the MCMC
##'     algorithm. Default is 1000. Though usually much larger numbers are used
##' @param burnin The number of samples to be discarded from the
##'     begining of the chain. Default is 100.
##' @param thin The thinning frequency to be applied to the MCMC
##'     chain.  Default is 5.
##' @param u The prior shape parameter for Beta(u, v). Default is 2
##' @param v The prior shape parameter for Beta(u, v). Default is 10.
##' @param lambda Controls the variance of the outlier component. Default is 1.
##' @param gpParams Object of class gpparams. parameters from prior fitting of GPs
##' to each niche to accelerate inference. Default is NULL.
##' @param hyperIter The frequency of MCMC interation to update the hyper-parameters
##' default is 20
##' @param hyperMean The prior mean of the log normal prior of the GP parameters.
##' Default is 0 for each. Order is length-scale, amplitude and noise variance
##' @param hyperSd The prior standard deviation of the log normal prior fo the GP
##' parameters. Default is 1 for each. Order is length-scale, ampliture and noise
##'  variance.
##' @param seed The random number seed.
##' @param pg `logical` indicating whether to use polya-gamma prior. Default is
##'  `FALSE`.
##' @param pgPrior A matrix generated by pgPrior function. If param pg is TRUE
##' but pgPrior is NULL then a pgPrior is generated on the fly.
##' @param tau The tau parameter for the polya-Gamma prior (is used). Defaults
##' to 0.2
##' @param dirPrior A matrix generated by dirPrior function. Default is NULL
##'  and dirPrior is generated on the fly.
##' @param maternCov `logical` indicated whether to use a matern or gaussian
##' covariance. Default is True and matern covariance is used
##' @param PC `logical` indicating whether to use a penalised complexity prior.
##' Default is TRUE.
##' @param pcPrior `numeric` of length 3 indicating the lambda paramters for the
##' penalised complexity prior. Default is `c(0.5, 3, 100)` and the order is 
##' length-scale, amplitude and variance.
##' @param nu `integter` indicating the smoothness of the matern prior. Default
##' is 2.
##' @param propSd If MH is used to learn posterior hyperparameters then the proposal
##' standard deviations. A Gaussian random-walk proposal is used.
##' @param numChains `integer` indicating the number of parallel chains to run.
##' Defaults to 4.
##' @param BPPARAM BiocParallel parameter. Defaults to machine default backend
##' using bpparam()


bandle <- function(objectCond1,
                   objectCond2,
                   fcol = "markers",
                   hyperLearn = "LBFGS",
                   numIter = 1000,
                   burnin = 100L,
                   thin = 5L,
                   u = 2,
                   v = 10,
                   lambda = 1,
                   gpParams = NULL,
                   hyperIter = 20,
                   hyperMean = c(0, 0, 0),
                   hyperSd = c(1, 1,1),
                   seed = NULL,
                   pg = FALSE,
                   pgPrior = NULL,
                   tau = 0.2,
                   dirPrior = NULL,
                   maternCov = TRUE,
                   PC = TRUE,
                   pcPrior = c(0.5, 3, 100),
                   nu = 2,
                   propSd = c(0.3, 0.1, 0.05),
                   numChains = 4L,
                   BPPARAM = BiocParallel::bpparam()){
    
    if (is.null(seed))
        seed <- sample(.Machine$integer.max, 1)
    .seed <- as.integer(seed)
    set.seed(.seed)
    
    
    
    ## chains run in parallel, repeating number of iterations
    .res <- bplapply(rep(numIter, numChains),
                     FUN = diffLoc,
                     objectCond1 = objectCond1,
                     objectCond2 = objectCond2,
                     fcol = fcol,
                     hyperLearn = hyperLearn,
                     #numIter = numIter, #parrallelised 
                     burnin = burnin,
                     thin = thin,
                     u = u,
                     v = v,
                     lambda = lambda,
                     gpParams = gpParams,
                     hyperIter = hyperIter,
                     hyperMean = hyperMean,
                     hyperSd = hyperSd,
                     seed = seed,
                     pg = pg,
                     pgPrior = pgPrior,
                     tau = tau,
                     dirPrior = dirPrior,
                     maternCov = maternCov,
                     PC = PC,
                     pcPrior = pcPrior,
                     nu = nu,
                     propSd = propSd,
                     BPPARAM = BPPARAM)
    
    ## Construct class bandleChains
    .ans <- .bandleChains(chains = .res)
    
    ## Construct class bandleParams
    .out <- .bandleParams(method = "bandle",
                          priors = list(dirPrior = dirPrior,
                                        pgPrior = pgPrior,
                                        pcPrior = pcPrior,
                                        hyperMean = hyperMean,
                                        hyperSd = hyperSd), 
                          seed = .seed, 
                          summary = .bandleSummaries(
                                        summaries = list(.bandleSummary(),
                                                         .bandleSummary())),
                          chains = .ans)
    
    return(.out)
}

##' @param objectCond1 A list of instances of class [`MSnbase::MSnSet`]s
##' where each is an experimental replicate for the first condition, usually a control
##' @param objectCond2 A list of instance of class [`MSnbase::MSnSet`]s 
##' where each is an experimental replicate for the second condition, usually a treatment
##' @param params An instance of class `bandleParams`, as generated by
##'     [`bandle()`].
##' @return `bandlePredict` returns an instance of class
##'     [`MSnbase::MSnSet`] containing the localisation predictions as
##'     a new `bandle.allocation` feature variable. The allocation
##'     probability is encoded as `bandle.probability`
##'     (corresponding to the mean of the distribution
##'     probability). In addition the upper and lower quantiles of
##'     the allocation probability distribution are available as
##'     `bandle.probability.lowerquantile` and
##'     `bandle.probability.upperquantile` feature variables. The
##'     Shannon entropy is available in the `bandle.mean.shannon`
##'     feature variable, measuring the uncertainty in the allocations
##'     (a high value representing high uncertainty; the highest value
##'     is the natural logarithm of the number of classes). An additional variable
##'     indicating the differential localization probability is also added as
##'     `bandle.differential.localisation`
##' @md
##' @rdname bandle


bandlePredict <- function(objectCond1,
                          objectCond2,
                          params){

    stopifnot(inherits(bandle, "bandleParams"))
## Checks for object and bandleParams match
stopifnot(featureNames(unknownMSnSet(object, fcol = fcol))
          == rownames(params@summaries@posteriorEstimates))
    stopifnot(lapply(objectCond1, function(zz) inherits(zz, "MSnset")))
    stopifnot(lapply(objectCond2, function(zz) inherits(zz, "MSnset")))

    for (j in c(1, 2)){
    
    object <-  c(objectCond1, objectCond2)[j]

    ## Create marker set and size
    markerSet <- markerMSnSet(object, fcol = fcol)
    markers <- getMarkerClasses(object, fcol = fcol)
    M <- nrow(markerSet)
    K <- chains(params)[[1]]@K


    ## Get Summary object from bandleParams maybe better to check
    ## columns exist/pass which objects we need
    .bandle.allocation <- c(as.character(summaries(params)[[j]]@posteriorEstimates[,"bandle.allocation"]),
                          as.character(fData(markerSet)[, fcol]))
    .bandle.probability <- c(summaries(params)[[j]]@posteriorEstimates[,"bandle.probability"],
                           rep(1, M)) ## set all probabilities of markers to 1.
    .bandle.probability.lowerquantile <- c(summaries(params)[[j]]@posteriorEstimates[,"bandle.probability.lowerquantile"],
                                         rep(1, M)) ## set all probabilities of markers to 1.
    .bandle.probability.upperquantile <- c(summaries(params)[[j]]@posteriorEstimates[,"bandle.probability.upperquantile"],
                                         rep(1, M)) ## set all probabilities of markers to 1.
    .bandle.mean.shannon <- c(summaries(params)[[j]]@posteriorEstimates[,"bandle.mean.shannon"],
                            rep(0, M)) ## set all probabilities of markers to 0
    .bandle.differential.localisation <- c(summaries(params)[[j]]@posteriorEstimates[, "bandle.differential.localisation"],
                                           rep(0, M)) ## set differential localisation of markers to 0
    
    ## Create data frame to store new summaries
    .bandle.summary <- DataFrame(bandle.allocation = .bandle.allocation ,
                                bandle.probability = .bandle.probability,
                                bandle.probability.lowerquantile = .bandle.probability.lowerquantile,
                                bandle.probability.upperquantile = .bandle.probability.upperquantile,
                                bandle.mean.shannon = .bandle.mean.shannon,
                                bandle.differential.localisation = .bandle.differential.localisation)
    ## add outlier information
    .bandle.summary$bandle.outlier <- c(params@summary@posteriorEstimates[, "bandle.probability.Outlier"],
          rep(0, M)) ## set all probabilities of markers to 0
    
    
    ## Check number of rows match and add feature names
    stopifnot(nrow(.bandle.summary) == nrow(object))
    rownames(.bandle.summary) <- c(rownames(params@summary@posteriorEstimates),
                                 rownames(markerSet))
    
    ## Append data to fData of MSnSet
    fData(object) <- cbind(fData(object), .bandle.summary[rownames(fData(object)),])
    
    ## create allocation matrix for markers
    .probmat <- matrix(0, nrow = nrow(markerSet), ncol = K)
    .class <- fData(markerSet)[, fcol]
    for (j in seq_len(nrow(markerSet))) {
    ## give markers prob 1
        .probmat[j, as.numeric(factor(.class), seq(1, length(unique(.class))))[j]] <- 1
    }
    colnames(.probmat) <- markers
    rownames(.probmat) <- rownames(markerSet)
    .joint <- rbind(params@summary@bandle.joint, .probmat)
    fData(object)$bandle.joint <- .joint[rownames(fData(object)), ]
    
        if(j == 1){
            objectCond1 <- object
        } else {
            objectCond2 <- object
        }
    }
    
    .out <- list(objectCond1 = objectCond1,
                 objectCond2 = objectCond2)
    
    return(.out)
}

##' @return `bandleProcess` returns an instance of class
##'     `bandleParams` with its summary slot populated.
##' @md
##' @rdname bandle
bandleProcess <- function(params) {
    
    ## get require slots
    myChain <- chains(params)[[1]]
    numChains <- length(chains(params))
    N <- myChain@N
    K <- myChain@K
    n <- myChain@n
    
    ## storage
    meanComponentProb = vector("list", length = numChains)
    meanOutlierProb = vector("list", length = numChains)
    bandle.joint <- matrix(0, nrow = N, ncol = K)
    bandle.outlier <- matrix(0, nrow = N, ncol = 2)
    .bandle.quantiles <- array(0, c(N, K, 2))
    pooled.Component <- matrix(0, nrow = N, ncol = n * numChains)
    pooled.ComponentProb <- array(0, c(N, n * numChains, K ))
    pooled.Outlier <- matrix(0, nrow = N, ncol = n * numChains)
    pooled.OutlierProb <- array(0, c(N, n * numChains, 2 ))
    pooled.differential.localisation <- matrix(0, nrow = N, ncol = n * numChains)
    
    # Calculate basic quantities
    for (j in seq_len(numChains)) {
        
        mc <- chains(params)[[j]]
        meanComponentProb[[j]] <- t(apply(mc@ComponentProb[, , ], 1, colMeans))
        meanOutlierProb[[j]] <- t(apply(mc@OutlierProb[, , ], 1, colMeans))
        bandle.joint <- bandle.joint + meanComponentProb[[j]]
        bandle.outlier <- bandle.outlier + meanOutlierProb[[j]]
        ## Pool chains
        pooled.Component[, n * (j - 1) + seq.int(n)] <- mc@Component
        pooled.ComponentProb[, n * (j - 1) + seq.int(n), ] <- mc@ComponentProb
        pooled.Outlier[, n * (j - 1)+ seq.int(n)] <- mc@Outlier
        pooled.OutlierProb[, n * (j - 1) + seq.int(n), ] <- mc@OutlierProb
        pooled.differential.localisation[, n * (j - 1) + seq.int(n)] <- 1 - probsameorganelle(params)
        
    }
    ## take means across chains
    bandle.joint <- bandle.joint/numChains
    bandle.outlier <- bandle.outlier/numChains
    bandle.probability <- apply(bandle.joint, 1, max)
    bandle.allocation <- colnames(bandle.joint)[apply(bandle.joint, 1, which.max)]
    bandle.differential.localisation <- pooled.differential.localisation/numChains
    
    ## Calculate quantiles
    for (i in seq_len(N)) {
        for (j in seq_len(K)) {
            .bandle.quantiles[i, j, ] <- quantile(pooled.ComponentProb[i, , j],
                                                  probs = c(0.025, 0.975))
        }
    }
    
    ## Store quantiles
    bandle.probability.lowerquantile <- .bandle.quantiles[cbind(1:N,
                                                                apply(bandle.joint, 1, which.max), rep(1, N))]
    bandle.probability.upperquantile <- .bandle.quantiles[cbind(1:N,
                                                                apply(bandle.joint, 1, which.max), rep(2, N))]
    
    ## Compute Shannon Entropy
    bandle.shannon <- -apply(pooled.ComponentProb * log(pooled.ComponentProb), c(1,2), sum)
    bandle.shannon[is.na(bandle.shannon)] <- 0
    bandle.mean.shannon <- rowMeans(bandle.shannon)
    
    ## Name entries
    names(bandle.mean.shannon) <- names(bandle.probability.lowerquantile) <-
        names(bandle.probability.upperquantile) <- rownames(myChain@Component)
    rownames(bandle.joint) <- names(bandle.probability) <-
        names(bandle.allocation) <- rownames(myChain@Component)
    colnames(bandle.joint) <- rownames(myChain@ComponentParam@mk)
    
    ## Outlier colNames
    colnames(bandle.outlier) <- c("bandle.probability.notOutlier",
                                  "bandle.probability.Outlier")
    
    ## Compute convergence diagnostics
    weights <- vector("list", length = numChains)
    r_hat <- vector(mode = "list", length = K)
    
    for(j in seq_len(numChains)) {
        mc <- chains(params)[[j]]
        weight[[j]] <- coda::mcmc(mc@weights)
    }
    
    ## Summary of posterior estimates
    bandle.summary <- DataFrame(bandle.allocation,
                                bandle.probability,
                                bandle.outlier,
                                bandle.probability.lowerquantile,
                                bandle.probability.upperquantile,
                                bandle.mean.shannon,
                                bandle.differential.localisation)
    
    ## Compute convergence diagnostics
    if(numChains > 1){
        weights <- coda::as.mcmc.list(weight)
        gd <- coda::gelman.diag(x = weights, autoburnin = FALSE)
        .diagnostics <- gd$psrf
        rownames(.diagnostics) <- c("weights")
        
    }

    ## Constructor for summary
    params@summary <- .bandleSummary(posteriorEstimates = bandle.summary,
                                   diagnostics = .diagnostics,
                                   bandle.joint = bandle.joint)
    
    return(params)
}



